---
layout: post
title: 代码陷阱- 浮点数
keywords: 代码陷阱, 浮点数
category : codepuzzle
tags : [代码陷阱, 浮点数]
---


## 浮点数个数

> 在 8 位计算机上，浮点数一共有多少个呢？

“8 位的好像太过时了，现在主流的是 32 位的，好像可以表示3 x 10^38。”

> 8 位计算机可以表示的整数是多少个呢？

“这个简单，2的8次方，应该是 256 个。N 位计算机表示的整数就是 2 的 N 次方。”

> 8 位计算机，或者说 **8bit 可以表示 2^8 个整数**。
> 如果用这 8bit 来表示字符，可以表示多少个呢？

“呵呵，当然也是 2 的 8 次方了，否则就没有必要再发明16位或者32位的 unicode 去表示汉字了。”

> 如刚才所说，8bit 可以表示 3 x 10^38 个浮点数。那么你估算一下，2bit 可以表示多少个浮点数呢？

“既然 2bit 可以表示 4 个整数，浮点数嘛肯定比这个多，最少也得能表示 10 几个浮点数吧。”

> 好吧，按照你的思路，我说几个数。

> * 0总该有吧，用 00 表示。
> * 0.1 用 01 表示
> * 0.2 用 10 表示
> * 0.3 用 11 表示
>
> 现在你把 0.4 给我表示出来？

“哦。我明白了， **2bit 可以表示 4 个数，不管是整数、小数或者字符**，就算是用 2bit 表示苹果，我们也只能表示 4 个，如果想要表示更多，就得用更多的 bit 位。”


## 浮点数精度

你在crome浏览器下按下F12键，把下面的代码输入进去，你会吓一跳。

    0.2 + 0.4
    
    0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1

“这怎么可能呢？JS 居然这么不严格？”


> 任何语言都宣称他们的浮点数的表示范围是 3 x 10^38，这个数到底多大呢？目前所知宇宙的年龄是 1.373 x 10^10 年。
> 
> 但是 32bit 最多只能表示 2^32 个数，大约是 4 x 10^9。
> 
> 对比一下你就会发现令人震惊的结果。
> 如果把浮点数的范围比做地球，那么可以精确表示的浮点数还不到一粒芝麻大。

“这么说，0.2+0.4 是因为他不能够精确表示，所以出现了计算错误的现象。那在编程中如何避免这种问题呢？”

> 用 **定点数表示小数**。

## 浮点数等价于小数吗

> **整数和小数是数学里面的概念，在计算机中，只有定点数和浮点数，没有整数和小数**。
>
> 定点数在课本里如何定义的？

> 定点、浮点，“点”是什么意思？“点”就是小数点。
> 把小数点固定，通常固定在最右面，就是定点数。
> 把小数点浮动，就是浮点数。浮点在哪儿？这个在 IEEE 浮点数标准里面定义的。

> 回到前面话题，如何精确的表示小数呢？其中一种方案就是定点数。
拿 8bit 举例吧。我们可以把小数点定在中间，用 4bit 表示整数部分，4bit 表示小数部分。
这样构造方式（专业点我们称他为数据结构，一般语言把整数和小数称为简单数据类型，其实他们一点都不简单，而且比那些成了复合数据类型的字符串都要复杂的多），<del>我们可以精确的表示64个小数</del>，我们可以精确的表示 2^8 = 256 个小数）。

------------------------------------

## 十进制 VS 二进制

下面我们讨论如何把十进制小数转换成二进制小数（什么？你不会？请自觉去面壁）。

考虑我们将 1/7（七分之一） 写成小数的时候是如何做的？

用 1 除以 7，得到的商就是小数部分，剩下的余数我们继续除以 7，一直除到什么时候结束呢？
有两种情况：

1. 如果余数为 0。yeah！终于结束了，洗洗睡吧

2. 当除到某一步时，余数等于 1… 停！stop！等一下，我发现有什么地方怪怪的。余数为 1，余数如果为 1 的话，再继续除下去，不就又是 1/7 了吗？绕了一个大弯，又回来了？对，你猜的很对，它永远不会结束，它循环了。

注意我上面说的 情况2，我们判断他循环，并 **不是从直观看感觉它重复了，而是因为 **在计算过程中，它又回到了开头**。为什么这么说呢？当你计算一个分数时，它总是连续出现 5，出现了好多次，例如 0.5555555… 你也无法断定它是无限循环的，比如 一亿分之五。

记得高中时，从一本数学课外书学到了手动开平方的方法，于是很兴奋的去计算 2 的平方根，发现它的前几位是 1.414，哇，原来「2的平方根」等于 1.414141…。很多天以后，当我再次看到我的笔记时，只能苦笑了，「2的平方根」不可能循环啊，它可是一个无理数啊。

你可能不耐烦了，叽哩哇啦说这么多，有用吗？当然有用了，以后如果 MM 问你：你会爱我到什么时候？你可以回答她：我会爱你到 1/7 的尽头。难道我会把我的表白方式告诉你们吗？ **我对你的爱就像圆周率，无限——却永不重复。**

扯远了，现在会到主题。
你也许会说：我明白了，循环小数不能精确表示，放到计算机中会丢失精度；
那么有限小数可以精确表示吧，比如 0.1。

对于无限小数，不只是计算机不能精确表示，即使你用别的办法（省略号除外），比如纸、黑板、写字板…都无法精确表示。什么？手机？也不能，当然不能了。不，不，iPad也不行，1万买的也不行，真的，再贵的本子也写不下。

## 哪些数能精确表示？

那么 0.1 在计算机中可以精确表示吗？

答案是出人意料的， **不能**。

在此之前，先思考个问题：
**在 0.1 到 0.9 的 9 个小数中，有多少可以用二进制精确表示呢？**

我们按照乘以 2 取整数位的方法，把 0.1 表示为二进制（我假设那些不会进制转换的同学已经补习完了）：

    (1) 0.1 x 2 = 0.2  取整数位 0 得 0.0
    (2) 0.2 x 2 = 0.4  取整数位 0 得 0.00
    (3) 0.4 x 2 = 0.8  取整数位 0 得 0.000
    (4) 0.8 x 2 = 1.6  取整数位 1 得 0.0001
    (5) 0.6 x 2 = 0.2  取整数位 1 得 0.00011
    (6) 0.2 x 2 = 0.4  取整数位 0 得 0.000110
    (7) 0.4 x 2 = 0.8  取整数位 0 得 0.0001100
    (8) 0.8 x 2 = 1.6  取整数位 1 得 0.00011001
    (9) 0.6 x 2 = 1.2  取整数位 1 得 0.000110011
    (n) ...

我们得到一个无限循环的二进制小数 0.000110011...

我为什么要把这个计算过程这么详细的写出来呢？就是为了让你看，多看几遍，再多看几遍，继续看…
还没看出来，好吧，把眼睛揉一下，我提示你，把第一行去掉，从 (2) 开始看，看到 (6)，对比一下 (2) 和 (6)。
然后把前两行去掉，从 (3) 开始看…

明白了吧，0.2、0.4、0.6、0.8 都不能精确的表示为二进制小数。
难以置信，这可是所有的偶数啊！那奇数呢？
答案就是：

**0.1 到 0.9 的 9 个小数中，只有 0.5 可以用二进制精确的表示。**

如果把 0.0 再算上，那么就有两个数可以精确表示，一个奇数 0.5，一个偶数 0.0。
为什么是两个呢？因为计算机二呗，其实计算机还真够二的。

> 世界上有 10 种人，一种是懂二进制的，一种是不懂二进制的。 

其实答案很显然，我再领大家换个角度思考，0.5 就是一半的意思。
在十进制中，进制的基数是 10，而 5 正好是 10 的一半。
2 的一半是多少？当然是 1 了。
所以，十进制的 0.5 就是二进制的 0.1。如果我用八进制呢？
不用计算你就应该立刻回答：0.4；转换成十六进制呢，当然就是 0.8 了。

(0.5)<sub>10</sub> = (0.1)<sub>2</sub> = (0.4)<sub>8</sub> = (0.8)<sub>16</sub>


那么到底怎么确定一个数能否精确表示呢？还是回到我们熟悉的十进制分数。

1/2、5/9、34/25 哪些可以写成有限小数？把一个分数化到最简（分子分母无公约数），如果分母的因式分解只有 2 和 5，那么就可以写成有限小数，否则就是无限循环小数。为什么是 2 和 5 呢？因为他们是 10 的因子 10 = 2 x 5。

二进制和十六进制呢？他们的因子只有 2，所以十六进制只是二进制的一种简写形式，它的精度和二进制一样。

**如果一个十进制数可以用二进制精确表示，那么它的最后一位肯定是 5。**

## 精度在哪儿丢失？

在 java 中计算 0.2 + 0.4 得到的结果是 

    // 代码(a)
    double d = 0.2 + 0.4;  // 结果是 0.6000000000000001

但是当直接输出 0.6 的时候，确实是 0.6

    // 代码(b)
    double d = 0.6;  // 结果是 0.6

好像很矛盾。很显然，通过代码(b)可以知道，在 java 中，可以精确 **显示** 0.6，哪怕 0.6 不能被精确表示，但至少能精确把 0.6 显示出来，这不是和代码(a)矛盾了吗？

这又是一个 **想当然的错误**，在直观上认为 0.2 + 0.4 = 0.6 是必然成立的（在数学上确实如此），既然(a)的结果是 0.6，而且 java 可以精确输出 0.6，那么代码(a)的结果应该输出 0.6。

其实在计算机上 0.2 + 0.4 根本就不等于 0.6，因为 0.2 和 0.4 都不能被精确表示。
**浮点数的精度丢失在每一个表达式，而不仅仅是表达式的求值结果。**

我们用数学中的概念类比一下，比如四舍五入，我们计算 1.6 + 2.8 保留整数。

    1.6 + 2.8 = 4.4 
    
四舍五入得到 4。我们用另一种方法

    先把 1.6 四舍五入为 2
    再把 2.8 四舍五入为 3
    最后求和 2 + 3 = 5

通过两种运算，我们得到了两个结果 4 和 5。同理，在我们的浮点数运算中，参与运算的两个数 0.2 和 0.4 精度已经丢失了，所以他们求和的结果已经不是 0.6 了。

